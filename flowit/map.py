from copy import deepcopy
from enum import Enum
from dataclasses import dataclass
from typing import TypeAlias

class Direction(Enum):
    UP=(0, -1)
    RIGHT=(1, 0)
    LEFT=(-1, 0)
    DOWN=(0, 1)
    
'''
This is the logic array for when a bomb block is used.
Each array is a map that will be generated by the move_bomb() function.
A "None" means that the tile under the virtual cursor used in the
Bomb function will replace the tile with the bomb's color and
a "Direction" means that the virtual cursor will be moved.
'''
bomb_offsets: list[list[Direction | None]] = [
    # ...
    # .B.
    # ...
    [
        None
    ],
    # ...
    # .X.
    # ...
    [
        Direction.UP,
        None,
        Direction.DOWN, Direction.RIGHT,
        None,
        Direction.LEFT, Direction.DOWN,
        None,
        Direction.UP, Direction.LEFT,
        None,
        Direction.RIGHT
    ],
    # .X.
    # XXX
    # .X.
    [
        Direction.UP, Direction.LEFT,
        None,
        Direction.RIGHT, Direction.RIGHT,
        None,
        Direction.DOWN, Direction.DOWN,
        None,
        Direction.LEFT, Direction.LEFT,
        None,
        Direction.UP, Direction.RIGHT
    ]
    # XXX
    # XXX
    # XXX
]

class Color(Enum):
    NONE="0"
    RED="r"
    ORANGE="o"
    GREEN="g"
    BLUE="b"
    DARK="d"

# This is a string containing all of the color chars for easy checking if something represents a color with "in"
# color_chars_list = [e.value for e in Color]
# color_chars_list.remove(Color.NONE.value)
# color_chars = "".join(color_chars_list)
# del color_chars_list
color_chars = "".join([e.value for e in Color])


class Modifier(Enum):
    NONE="0"
    DISABLED="X"
    FLOOD="F"
    UP="U"
    RIGHT="R"
    LEFT="L"
    DOWN="D"
    BOMB="B"
    UP_R="w"
    RIGHT_R="x"
    LEFT_R="a"
    DOWN_R="s"
    RED="r"
    ORANGE="o"
    GREEN="g"
    BLUE="b"
    DARK="d"

modifier_direction_map: dict[Modifier, Direction] = {
    Modifier.UP: Direction.UP,
    Modifier.RIGHT: Direction.RIGHT,
    Modifier.LEFT: Direction.LEFT,
    Modifier.DOWN: Direction.DOWN,
    Modifier.UP_R: Direction.UP,
    Modifier.RIGHT_R: Direction.RIGHT,
    Modifier.LEFT_R: Direction.LEFT,
    Modifier.DOWN_R: Direction.DOWN
}

rotate_map: dict[Modifier, Modifier] = {
    Modifier.UP_R: Modifier.RIGHT_R,
    Modifier.RIGHT_R: Modifier.DOWN_R,
    Modifier.LEFT_R: Modifier.UP_R,
    Modifier.DOWN_R: Modifier.LEFT_R,
}

@dataclass
class Block():
    color: Color
    modifier: Modifier

# Class for position and position checking
@dataclass
class Coordinate():
    def __init__(self, x: int, y: int):
        self.x = x
        self.y = y
    
    def offset(self, direction: Direction) -> "Coordinate":
        return Coordinate(self.x + direction.value[0], self.y + direction.value[1])

    def copy(self) -> "Coordinate":
        return Coordinate(self.x, self.y)
    
    # For use in dictionaries primarily in the "flood" modifier
    # Generates a simple 32-bit "hash" using bitwise operators
    # The first 16 bits represent x and last 16 bits represent y
    def __hash__(self) -> int:
        return self.x << 16 | self.y
    
    def __str__(self) -> str:
        return f"Coordinate ({self.x}, {self.y})"

MapSequence: TypeAlias = list["Map"]

class Map():
    def __init__(self, data: list[list[Block]]) -> None:
        self.size = (len(data[0]), len(data))
        self.data = data
    
    def copy(self) -> "Map":
        return Map(deepcopy(self.data))
    
    # Check if coodinate is within map bounds
    def contains_coordinate(self, coordinate: Coordinate) -> bool:
        return not (coordinate.x < 0 or coordinate.y < 0 or coordinate.x > self.size[0] - 1 or coordinate.y > self.size[1] - 1)

    # Returns block at specified coordinate if inside map, otherwise returns an empty block
    def get_block(self, pos: Coordinate) -> Block:
        if self.contains_coordinate(pos):
            return self.data[pos.y][pos.x]
        else:
            return Block(Color.NONE, Modifier.DISABLED)
    
    # Handles moving for all arrow modifier types
    # Modifier.UP,   Modifier.RIGHT,   Modifier.LEFT,   Modifier.DOWN
    # Modifier.UP_R, Modifier.RIGHT_R, Modifier.LEFT_R, Modifier.DOWN_R
    def move_arrow(self, position: Coordinate, start_map: "Map", direction: Direction) -> MapSequence:
        maps = []
        map = start_map

        cursor = position.copy()
        start_block = map.get_block(cursor)

        # Rotate start block if it is rotating
        is_rotator = start_block.modifier in [Modifier.UP_R, Modifier.RIGHT_R, Modifier.LEFT_R, Modifier.DOWN_R]
        if is_rotator:
            start_block.modifier = rotate_map[start_block.modifier]
            maps.append(map.copy())
        
        cursor = cursor.offset(direction)
        first_move_block = map.get_block(cursor)

        # Add mode if first block's modifier is the move arrow's color
        add_mode = first_move_block.modifier.value != start_block.color.value
        
        while True:
            block = map.get_block(cursor)
            if add_mode:
                # Fill block if empty
                if block.modifier == Modifier.NONE:
                    block.modifier = Modifier(start_block.color.value)
                    maps.append(map.copy())
                # Stop if full
                else:
                    return maps
            else:
                # Clear block if it's modifier is the arrow's color
                if block.modifier.value == start_block.color.value:
                    block.modifier = Modifier.NONE
                    maps.append(map.copy())
                # Stop otherwise
                else:
                    return maps
            cursor = cursor.offset(direction)
    
    # Handles moving for the flood modifier
    # Modifier.FLOOD
    def move_flood(self, position: Coordinate, start_map: "Map") -> MapSequence:
        maps = []
        map = start_map

        cursor = position.copy()
        start_block = map.get_block(cursor)

        # Run conditions/behaviors
        # Precheck:
        # If there aren't any color blocks at all around the flood, don't run at all
        # If there isn't an empty block or a block with the target color, don't run at all
        # Main check:
        # If there is an empty block, use add mode
        # If there isn't an empty block, use subtract mode
        contains_empty = False
        contains_target = False
        contains_any_color = False
        # Initially check in all 4 directions around the flood
        for block in [map.get_block(cursor.offset(dir)) for dir in Direction]:
            if block.modifier == Modifier.NONE:
                contains_empty = True
            if block.modifier.value in color_chars:
                contains_any_color = True
            if block.modifier.value == start_block.color.value:
                contains_target = True
        if not contains_any_color or not(contains_empty or contains_target):
            return []
        add_mode = contains_empty

        # Create queue for blocks to check on each flood step
        check_queue: list[Coordinate] = []
        # Check in all directions first
        for dir in Direction:
            check_pos = cursor.offset(dir)
            if self.contains_coordinate(check_pos):
                check_queue.append(check_pos)
        
        # Dev note:
        # Attemped using a set to keep track of all changes made to the map to avoid re-checking
        # but it ended up being slightly slower than just re-checking some blocks so it was removed
        while True:
            # New queues for next iteration
            new_check_queue: list[Coordinate] = [] # List for actual queue since sets aren't good iterables
            new_check_queue_set: set[Coordinate] = set() # Set for constant-time checking of existing values in queue

            # Keep track of changes made this iteration
            # 0 changes in iteration means that all movement is done
            changes = 0
            for coordinate in check_queue:
                block = map.get_block(coordinate)
                change_made = False
                if add_mode:
                    # If block is empty, replace with flood color
                    if block.modifier == Modifier.NONE:
                        change_made = True
                        block.modifier = Modifier(start_block.color.value)
                else:
                    # If block is flood color, clear the block
                    if block.modifier.value == start_block.color.value:
                        change_made = True
                        block.modifier = Modifier.NONE
                if change_made:
                    changes += 1
                    # Queue new checks in each direction around the checked block
                    for dir in Direction:
                        new_coordinate = coordinate.offset(dir)
                        # If coordinate is inside map and not already queue
                        if map.contains_coordinate(new_coordinate) and new_coordinate not in new_check_queue_set:
                            # Add coordinate to queue
                            new_check_queue_set.add(new_coordinate)
                            new_check_queue.append(new_coordinate)
            
            # Swap queues and add generated map
            check_queue = new_check_queue
            if changes == 0:
                # Quit iterating if no changes were made
                return maps
            else:
                maps.append(map.copy())

    # Handles moving for the bomb modifier
    # Modifier.BOMB
    def move_bomb(self, position: Coordinate, start_map: "Map") -> MapSequence:
        maps = []
        map = start_map

        cursor = position.copy()
        start_block = map.get_block(cursor)
        # Bomb movement data structure:
        # list[list[Direction | None]]
        for offset_step in bomb_offsets:
            for offset in offset_step:
                # Replace tile on "None"
                if offset == None:
                    if map.contains_coordinate(cursor):
                        block = map.get_block(cursor)
                        if block.modifier != Modifier.DISABLED:
                            # Replace block if it is in bounds and not disabled
                            block.modifier = Modifier(start_block.color.value)
                else: # Move cursor on "Direction"
                    cursor = cursor.offset(offset)
            maps.append(map.copy())
        return maps

    # Generic move function that determines which movement function to use based on the modifier
    def move(self, position: Coordinate) -> MapSequence:
        # Copy map to be used with the move functions to prevent overwriting
        start_map = self.copy()
        maps = []

        block = self.get_block(position)
        match block.modifier:
            case Modifier.UP | Modifier.RIGHT | Modifier.LEFT | Modifier.DOWN | Modifier.UP_R | Modifier.RIGHT_R | Modifier.LEFT_R | Modifier.DOWN_R:
                direction = modifier_direction_map[block.modifier]
                maps = self.move_arrow(position, start_map, direction)
            case Modifier.FLOOD:
                maps = self.move_flood(position, start_map)
            case Modifier.BOMB:
                maps = self.move_bomb(position, start_map)
        
        # Update this map to be the final map of the used move function.
        # The other maps are used by whatever is implementing this module such as a GUI/TUI
        if len(maps) > 0:
            self.data = maps[-1].data
        return maps
    
    # Check if this map is solved by comparing it to the start map
    # def is_solved(self, start_map: "Map") -> bool:
    #     for y in range(len(self.data)):
    #         for x in range(len(self.data[y])):
    #             current_block = self.get_block(Coordinate(x, y))
    #             original_block = start_map.get_block(Coordinate(x, y))
    #             if original_block.modifier.value in color_chars or original_block.modifier == Modifier.NONE:
    #                 if original_block.color.value != current_block.modifier.value:
    #                     return False
    #     return True
    def is_solved(self) -> bool:
        for y in range(len(self.data)):
            for x in range(len(self.data[y])):
                block = self.get_block(Coordinate(x, y))
                if block.modifier.value in color_chars or block.modifier == Modifier.NONE:
                    if block.color.value != block.modifier.value:
                        return False
        return True